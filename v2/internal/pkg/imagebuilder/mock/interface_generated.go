// Code generated by MockGen. DO NOT EDIT.
// Source: ./interface.go
//
// Generated by this command:
//
//	mockgen -source=./interface.go -destination=./mock/interface_generated.go -package=mock
//

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"

	v1 "github.com/google/go-containerregistry/pkg/v1"
	layout "github.com/google/go-containerregistry/pkg/v1/layout"
	v2alpha1 "github.com/openshift/oc-mirror/v2/internal/pkg/api/v2alpha1"
	gomock "go.uber.org/mock/gomock"
)

// MockImageBuilderInterface is a mock of ImageBuilderInterface interface.
type MockImageBuilderInterface struct {
	ctrl     *gomock.Controller
	recorder *MockImageBuilderInterfaceMockRecorder
	isgomock struct{}
}

// MockImageBuilderInterfaceMockRecorder is the mock recorder for MockImageBuilderInterface.
type MockImageBuilderInterfaceMockRecorder struct {
	mock *MockImageBuilderInterface
}

// NewMockImageBuilderInterface creates a new mock instance.
func NewMockImageBuilderInterface(ctrl *gomock.Controller) *MockImageBuilderInterface {
	mock := &MockImageBuilderInterface{ctrl: ctrl}
	mock.recorder = &MockImageBuilderInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockImageBuilderInterface) EXPECT() *MockImageBuilderInterfaceMockRecorder {
	return m.recorder
}

// BuildAndPush mocks base method.
func (m *MockImageBuilderInterface) BuildAndPush(ctx context.Context, targetRef string, layoutPath layout.Path, cmd []string, layers ...v1.Layer) (string, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, targetRef, layoutPath, cmd}
	for _, a := range layers {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BuildAndPush", varargs...)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BuildAndPush indicates an expected call of BuildAndPush.
func (mr *MockImageBuilderInterfaceMockRecorder) BuildAndPush(ctx, targetRef, layoutPath, cmd any, layers ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, targetRef, layoutPath, cmd}, layers...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuildAndPush", reflect.TypeOf((*MockImageBuilderInterface)(nil).BuildAndPush), varargs...)
}

// ProcessImageIndex mocks base method.
func (m *MockImageBuilderInterface) ProcessImageIndex(ctx context.Context, idx v1.ImageIndex, v2format *bool, cmd []string, targetRef string, layers ...v1.Layer) (v1.ImageIndex, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, idx, v2format, cmd, targetRef}
	for _, a := range layers {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ProcessImageIndex", varargs...)
	ret0, _ := ret[0].(v1.ImageIndex)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ProcessImageIndex indicates an expected call of ProcessImageIndex.
func (mr *MockImageBuilderInterfaceMockRecorder) ProcessImageIndex(ctx, idx, v2format, cmd, targetRef any, layers ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, idx, v2format, cmd, targetRef}, layers...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProcessImageIndex", reflect.TypeOf((*MockImageBuilderInterface)(nil).ProcessImageIndex), varargs...)
}

// SaveImageLayoutToDir mocks base method.
func (m *MockImageBuilderInterface) SaveImageLayoutToDir(ctx context.Context, imgRef, layoutDir string) (layout.Path, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveImageLayoutToDir", ctx, imgRef, layoutDir)
	ret0, _ := ret[0].(layout.Path)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SaveImageLayoutToDir indicates an expected call of SaveImageLayoutToDir.
func (mr *MockImageBuilderInterfaceMockRecorder) SaveImageLayoutToDir(ctx, imgRef, layoutDir any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveImageLayoutToDir", reflect.TypeOf((*MockImageBuilderInterface)(nil).SaveImageLayoutToDir), ctx, imgRef, layoutDir)
}

// MockCatalogBuilderInterface is a mock of CatalogBuilderInterface interface.
type MockCatalogBuilderInterface struct {
	ctrl     *gomock.Controller
	recorder *MockCatalogBuilderInterfaceMockRecorder
	isgomock struct{}
}

// MockCatalogBuilderInterfaceMockRecorder is the mock recorder for MockCatalogBuilderInterface.
type MockCatalogBuilderInterfaceMockRecorder struct {
	mock *MockCatalogBuilderInterface
}

// NewMockCatalogBuilderInterface creates a new mock instance.
func NewMockCatalogBuilderInterface(ctrl *gomock.Controller) *MockCatalogBuilderInterface {
	mock := &MockCatalogBuilderInterface{ctrl: ctrl}
	mock.recorder = &MockCatalogBuilderInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCatalogBuilderInterface) EXPECT() *MockCatalogBuilderInterfaceMockRecorder {
	return m.recorder
}

// RebuildCatalog mocks base method.
func (m *MockCatalogBuilderInterface) RebuildCatalog(ctx context.Context, catalogCopyRefs v2alpha1.CopyImageSchema, configPath string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RebuildCatalog", ctx, catalogCopyRefs, configPath)
	ret0, _ := ret[0].(error)
	return ret0
}

// RebuildCatalog indicates an expected call of RebuildCatalog.
func (mr *MockCatalogBuilderInterfaceMockRecorder) RebuildCatalog(ctx, catalogCopyRefs, configPath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RebuildCatalog", reflect.TypeOf((*MockCatalogBuilderInterface)(nil).RebuildCatalog), ctx, catalogCopyRefs, configPath)
}
